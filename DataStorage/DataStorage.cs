using Dapper;
using DataStorage.Models;
using Dommel;
using FirebirdSql.Data.FirebirdClient;
using System;
using System.Collections.Generic;
using System.Data;
using System.Data.Common;
using System.IO;
using System.Linq;

namespace DataStorage {
    /// <summary>
    /// Sharded data storage for ASCOM ObservingConditions and SafetyMonitor data
    /// </summary>
    public class DataStorage {
        private readonly string _storageRootPath;
        private readonly string _userName;
        private readonly string _password;
        private const string DatabaseFileExtension = ".fdb";
        private const string TableName = "DATA";

        /// <summary>
        /// Initialize sharded data storage
        /// </summary>
        /// <param name="storageRootPath">Root directory for storing database shards</param>
        /// <param name="userName">FireBird user name (default: SYSDBA)</param>
        /// <param name="password">FireBird password (default: masterkey)</param>
        public DataStorage(string storageRootPath, string? userName = null, string? password = null) {
            if (string.IsNullOrWhiteSpace(storageRootPath)) {
                throw new ArgumentException("Storage root path cannot be null or empty", nameof(storageRootPath));
            }

            _storageRootPath = storageRootPath;
            _userName = string.IsNullOrWhiteSpace(userName) ? "SYSDBA" : userName;
            _password = string.IsNullOrWhiteSpace(password) ? "masterkey" : password;

            // Ensure root directory exists
            if (!Directory.Exists(_storageRootPath)) {
                Directory.CreateDirectory(_storageRootPath);
            }
        }

        /// <summary>
        /// Get database file path for a specific date
        /// </summary>
        private string GetDatabasePath(DateTime date) {
            var yearFolder = Path.Combine(_storageRootPath, date.Year.ToString());
            var dbFileName = $"{date:MM}{DatabaseFileExtension}";
            return Path.Combine(yearFolder, dbFileName);
        }

        /// <summary>
        /// Create database and table if they don't exist
        /// </summary>
        private void EnsureDatabaseExists(string dbPath) {
            var directory = Path.GetDirectoryName(dbPath);
            if (!Directory.Exists(directory)) {
                Directory.CreateDirectory(directory!);
            }

            if (!File.Exists(dbPath)) {
                // Create database with FireBird 5 on localhost
                var csb = new FbConnectionStringBuilder {
                    DataSource = "localhost",
                    Database = dbPath,
                    UserID = _userName,
                    Password = _password,
                    ServerType = FbServerType.Default,
                    Charset = "UTF8",
                    WireCrypt = FbWireCrypt.Enabled,
                    Pooling = false
                };

                FbConnection.CreateDatabase(csb.ToString());

                // Create table with IDENTITY column (FireBird 5 auto-increment)
                using var connection = new FbConnection(GetConnectionString(dbPath));
                connection.Open();

                using var command = connection.CreateCommand();
                command.CommandText = @"
                    CREATE TABLE DATA (
                        ID BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
                        TIMESTAMP TIMESTAMP NOT NULL,
                        CLOUD_COVER DOUBLE PRECISION,
                        DEW_POINT DOUBLE PRECISION,
                        HUMIDITY DOUBLE PRECISION,
                        PRESSURE DOUBLE PRECISION,
                        RAIN_RATE DOUBLE PRECISION,
                        SKY_BRIGHTNESS DOUBLE PRECISION,
                        SKY_QUALITY DOUBLE PRECISION,
                        SKY_TEMPERATURE DOUBLE PRECISION,
                        STAR_FWHM DOUBLE PRECISION,
                        TEMPERATURE DOUBLE PRECISION,
                        WIND_DIRECTION DOUBLE PRECISION,
                        WIND_GUST DOUBLE PRECISION,
                        WIND_SPEED DOUBLE PRECISION,
                        IS_SAFE INTEGER,
                        NOTES VARCHAR(1000)
                    );
                    
                    CREATE INDEX IDX_TIMESTAMP ON DATA(TIMESTAMP);
                ";
                command.ExecuteNonQuery();
            }
        }

        /// <summary>
        /// Get connection string for a database
        /// </summary>
        private string GetConnectionString(string dbPath) {
            var builder = new FbConnectionStringBuilder {
                DataSource = "localhost",
                Database = dbPath,
                UserID = _userName,
                Password = _password,
                ServerType = FbServerType.Default,
                Charset = "UTF8",
                WireCrypt = FbWireCrypt.Enabled
            };

            return builder.ToString();
        }

        /// <summary>
        /// Add observing data to storage
        /// </summary>
        /// <param name="data">Data to store</param>
        public void AddData(ObservingData data) {
            ArgumentNullException.ThrowIfNull(data);

            var dbPath = GetDatabasePath(data.Timestamp);
            EnsureDatabaseExists(dbPath);

            using var connection = new FbConnection(GetConnectionString(dbPath));
            connection.Open();

            // ID will be auto-generated by database
            data.Id = 0;
            connection.Insert(data);
        }

        /// <summary>
        /// Get data for a specific time range with optional aggregation
        /// </summary>
        /// <param name="startTime">Start of time range (inclusive)</param>
        /// <param name="endTime">End of time range (inclusive)</param>
        /// <param name="slotDuration">Duration of each time slot for aggregation (null for raw data)</param>
        /// <param name="aggregationFunction">Function to use for aggregation (only used if slotDuration is specified)</param>
        /// <returns>List of observing data (raw or aggregated) sorted by timestamp</returns>
        public List<ObservingData> GetData(
            DateTime startTime,
            DateTime endTime,
            TimeSpan? slotDuration = null,
            AggregationFunction aggregationFunction = AggregationFunction.Average) {
            if (endTime < startTime) {
                throw new ArgumentException("End time must be greater than or equal to start time");
            }

            if (slotDuration.HasValue && slotDuration.Value <= TimeSpan.Zero) {
                throw new ArgumentException("Slot duration must be positive");
            }

            // If no aggregation requested, return raw data
            if (!slotDuration.HasValue) {
                return GetRawData(startTime, endTime);
            }

            // Aggregate data using SQL
            return GetAggregatedData(startTime, endTime, slotDuration.Value, aggregationFunction);
        }

        /// <summary>
        /// Get raw data from database shards
        /// </summary>
        private List<ObservingData> GetRawData(DateTime startTime, DateTime endTime) {
            var results = new List<ObservingData>();

            // Iterate through all months in the range
            var currentDate = new DateTime(startTime.Year, startTime.Month, 1);
            var endDate = new DateTime(endTime.Year, endTime.Month, 1);

            while (currentDate <= endDate) {
                var dbPath = GetDatabasePath(currentDate);

                if (File.Exists(dbPath)) {
                    using var connection = new FbConnection(GetConnectionString(dbPath));
                    connection.Open();

                    var data = connection
                        .GetAll<ObservingData>()
                        .Where(e => e.Timestamp >= startTime && e.Timestamp <= endTime)
                        .ToList();

                    results.AddRange(data);
                }

                currentDate = currentDate.AddMonths(1);
            }

            return [.. results.OrderBy(d => d.Timestamp)];
        }

        /// <summary>
        /// Get aggregated data using Dapper for better performance and type safety
        /// </summary>
        private List<ObservingData> GetAggregatedData(
            DateTime startTime,
            DateTime endTime,
            TimeSpan slotDuration,
            AggregationFunction aggregationFunction) {
            var results = new List<ObservingData>();
            var slotSeconds = (long)slotDuration.TotalSeconds;

            // Iterate through all months in the range
            var currentDate = new DateTime(startTime.Year, startTime.Month, 1);
            var endDate = new DateTime(endTime.Year, endTime.Month, 1);

            while (currentDate <= endDate) {
                var dbPath = GetDatabasePath(currentDate);

                if (File.Exists(dbPath)) {
                    using var connection = new FbConnection(GetConnectionString(dbPath));
                    connection.Open();

                    string query;

                    // For First and Last, we need a different query strategy
                    if (aggregationFunction == AggregationFunction.First ||
                        aggregationFunction == AggregationFunction.Last) {
                        query = BuildFirstLastQuery(aggregationFunction);
                    } else {
                        query = BuildStandardAggregationQuery(aggregationFunction);
                    }

                    // Execute query using Dapper - maps directly to ObservingData
                    var aggregatedData = connection.Query<ObservingData>(
                        query,
                        new { StartTime = startTime, EndTime = endTime, SlotSeconds = slotSeconds }
                    );

                    results.AddRange(aggregatedData);
                }

                currentDate = currentDate.AddMonths(1);
            }

            return [.. results.OrderBy(d => d.Timestamp)];
        }

        /// <summary>
        /// Build query for standard aggregation functions (AVG, MIN, MAX, SUM, COUNT)
        /// </summary>
        private static string BuildStandardAggregationQuery(AggregationFunction function) {
            string sqlFunc = function switch {
                AggregationFunction.Average => "AVG",
                AggregationFunction.Minimum => "MIN",
                AggregationFunction.Maximum => "MAX",
                AggregationFunction.Sum => "SUM",
                AggregationFunction.Count => "COUNT",
                _ => throw new ArgumentException($"Unknown aggregation function: {function}")
            };

            return $@"
                SELECT 
                    MIN(TIMESTAMP) as Timestamp,
                    MAX(TIMESTAMP) as TimestampEnd,
                    COUNT(*) as RecordCount,
                    {sqlFunc}(CLOUD_COVER) as CloudCover,
                    {sqlFunc}(DEW_POINT) as DewPoint,
                    {sqlFunc}(HUMIDITY) as Humidity,
                    {sqlFunc}(PRESSURE) as Pressure,
                    {sqlFunc}(RAIN_RATE) as RainRate,
                    {sqlFunc}(SKY_BRIGHTNESS) as SkyBrightness,
                    {sqlFunc}(SKY_QUALITY) as SkyQuality,
                    {sqlFunc}(SKY_TEMPERATURE) as SkyTemperature,
                    {sqlFunc}(STAR_FWHM) as StarFwhm,
                    {sqlFunc}(TEMPERATURE) as Temperature,
                    {sqlFunc}(WIND_DIRECTION) as WindDirection,
                    {sqlFunc}(WIND_GUST) as WindGust,
                    {sqlFunc}(WIND_SPEED) as WindSpeed,
                    SUM(CASE WHEN IS_SAFE = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(IS_SAFE), 0) as SafePercentage
                FROM DATA
                WHERE TIMESTAMP >= @StartTime AND TIMESTAMP <= @EndTime
                GROUP BY CAST(DATEDIFF(SECOND, TIMESTAMP '1970-01-01 00:00:00', TIMESTAMP) / @SlotSeconds AS BIGINT)
                ORDER BY Timestamp
            ";
        }

        /// <summary>
        /// Build query for First and Last aggregation functions
        /// </summary>
        private static string BuildFirstLastQuery(AggregationFunction function) {
            string orderDirection = function == AggregationFunction.First ? "ASC" : "DESC";

            // Use ROW_NUMBER to find first/last record in each slot by timestamp
            return $@"
                WITH RankedData AS (
                    SELECT 
                        *,
                        CAST(DATEDIFF(SECOND, TIMESTAMP '1970-01-01 00:00:00', TIMESTAMP) / @SlotSeconds AS BIGINT) as TimeSlot,
                        ROW_NUMBER() OVER (
                            PARTITION BY CAST(DATEDIFF(SECOND, TIMESTAMP '1970-01-01 00:00:00', TIMESTAMP) / @SlotSeconds AS BIGINT) 
                            ORDER BY TIMESTAMP {orderDirection}
                        ) as RowNum
                    FROM DATA
                    WHERE TIMESTAMP >= @StartTime AND TIMESTAMP <= @EndTime
                )
                SELECT 
                    MIN(TIMESTAMP) as Timestamp,
                    MAX(TIMESTAMP) as TimestampEnd,
                    COUNT(*) as RecordCount,
                    MAX(CASE WHEN RowNum = 1 THEN CLOUD_COVER END) as CloudCover,
                    MAX(CASE WHEN RowNum = 1 THEN DEW_POINT END) as DewPoint,
                    MAX(CASE WHEN RowNum = 1 THEN HUMIDITY END) as Humidity,
                    MAX(CASE WHEN RowNum = 1 THEN PRESSURE END) as Pressure,
                    MAX(CASE WHEN RowNum = 1 THEN RAIN_RATE END) as RainRate,
                    MAX(CASE WHEN RowNum = 1 THEN SKY_BRIGHTNESS END) as SkyBrightness,
                    MAX(CASE WHEN RowNum = 1 THEN SKY_QUALITY END) as SkyQuality,
                    MAX(CASE WHEN RowNum = 1 THEN SKY_TEMPERATURE END) as SkyTemperature,
                    MAX(CASE WHEN RowNum = 1 THEN STAR_FWHM END) as StarFwhm,
                    MAX(CASE WHEN RowNum = 1 THEN TEMPERATURE END) as Temperature,
                    MAX(CASE WHEN RowNum = 1 THEN WIND_DIRECTION END) as WindDirection,
                    MAX(CASE WHEN RowNum = 1 THEN WIND_GUST END) as WindGust,
                    MAX(CASE WHEN RowNum = 1 THEN WIND_SPEED END) as WindSpeed,
                    SUM(CASE WHEN IS_SAFE = 1 THEN 1 ELSE 0 END) * 100.0 / NULLIF(COUNT(IS_SAFE), 0) as SafePercentage
                FROM RankedData
                GROUP BY TimeSlot
                ORDER BY Timestamp
            ";
        }
    }
}
